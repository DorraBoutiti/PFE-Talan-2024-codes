@Post('createDocument')
  async createDocument(
    @UploadedFile() file: Express.Multer.File,
    @Body('candidatId') candidatId: number,
    @Res() response,
  ) {
    console.log('createDocument called with file:', file);
    console.log('createDocument called with candidatId:', candidatId);

    try {
      // Validate file upload
      if (!file || !file.filename) {
        console.error('Invalid file uploaded');
        return response.status(HttpStatus.BAD_REQUEST).json({
          message: 'Invalid file uploaded',
          status: HttpStatus.BAD_REQUEST,
        });
      }

      // Check if the document is in the list of requested documents
      const requestedDocuments = await this.getDocumentsByCandidatId(candidatId);
      if (!this.isDocumentRequested(file.originalname, requestedDocuments)) {
        console.error('Document not requested');
        return response.status(HttpStatus.UNPROCESSABLE_ENTITY).json({
          message: 'Document not requested',
          status: HttpStatus.UNPROCESSABLE_ENTITY,
        });
      }

      // Upload file and get base64 encoded images
      const base64Images = await this.uploadFileAndGetBase64(file);
      
      // Enhance images
      const enhancedImages = await this.enhanceImages(base64Images);

      // Validate enhanced images
      this.validateEnhancedImages(enhancedImages);

      // Perform OCR on the enhanced image
      const ocrText = await this.performOCR(enhancedImages[0]);

      // Classify document based on OCR text
      const documentType = await this.classifyDocument(ocrText);

      // Create and save the document
      const newDocument = await this.createAndSaveDocument(file, candidatId, documentType, enhancedImages);

      return response.status(HttpStatus.CREATED).json({
        message: 'Document created successfully',
        status: HttpStatus.CREATED,
        document: newDocument,
      });
    } catch (error) {
      console.error('Error creating document:', error);
      return response.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        message: 'Internal server error',
        status: HttpStatus.INTERNAL_SERVER_ERROR,
      });
    }
  }

  private async getDocumentsByCandidatId(candidatId: number) {
    try {
      return await this.documentService.getDocumentsByCandidatId(candidatId);
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw new NotFoundException(error.message);
      }
      throw error;
    }
  }

  private isDocumentRequested(filename: string, requestedDocuments: any[]): boolean {
    return requestedDocuments.some(doc => doc.filename === filename);
  }

  private async uploadFileAndGetBase64(file: Express.Multer.File): Promise<string[]> {
    const formData = new FormData();
    formData.append('file', createReadStream(file.path), file.originalname);

    const apiUrl = `http://module-upload:${process.env.MODULE_UPLOAD_DOCKER_PORT}`;
    const responseFromUpload = await axios.post(`${apiUrl}/file-to-base64`, formData, {
      headers: formData.getHeaders(),
    });

    console.log('Response from upload:', responseFromUpload.data);
    return responseFromUpload.data.images;
  }

  private async enhanceImages(images: string[]): Promise<string[]> {
    const enhanceApiUrl = `http://module_image_enhancement:${process.env.MODULE_IMAGE_DOCKER_PORT}`;

    try {
      const enhancedImageResponses = await Promise.all(
        images.map(async (base64Image) => {
          const enhanceResponse = await axios.post(`${enhanceApiUrl}/enhance/base64`, { image: base64Image });
          return enhanceResponse.data.image;
        })
      );
      console.log('Enhanced images received');
      return enhancedImageResponses;
    } catch (error) {
      console.error('Error during image enhancement:', error);
      throw new Error('Failed to enhance image');
    }
  }

  private validateEnhancedImages(images: string[]): void {
    const isValidBase64 = (base64Str: string) => {
      const base64Pattern = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
      return base64Pattern.test(base64Str);
    };

    const invalidImages = images.filter(image => !isValidBase64(image));
    if (invalidImages.length > 0) {
      console.error('Invalid Base64 images found:', invalidImages);
      throw new Error('Invalid Base64 encoded images');
    }
    console.log('All enhanced images are valid Base64');
  }

  private async performOCR(base64Image: string): Promise<string> {
    const language = 'fr';
    const encodedLanguage = encodeURIComponent(language);
    const endpointUrl = `http://module_ocr:${process.env.MODULE_OCR_DOCKER_PORT}/ocr/predict-by-base64?language=${encodedLanguage}`;
    const requestBody = {
      base64_str: base64Image,
    };

    const timeout = 25 * 60 * 1000; // 25 minutes in milliseconds
    const axiosConfig = {
      timeout: timeout,
      headers: {
        'accept': 'application/json',
        'Content-Type': 'application/json'
      }
    };

    try {
      const ocrResponse = await axios.post(endpointUrl, requestBody, axiosConfig);
      console.log('OCR Response:', ocrResponse.data);
      return ocrResponse.data;
    } catch (error) {
      console.error('Error during OCR:', error);
      throw new Error('Failed to perform OCR');
    }
  }

  private async classifyDocument(ocrText: string): Promise<string> {
    const classificationApiUrl = `http://module_classification:${process.env.MODULE_CLASSIFICATION_DATA_DOCKER_PORT}`;

    try {
      const classifyResponse = await axios.post(`${classificationApiUrl}/classify-document`, { document_text: ocrText });
      console.log('Document classified as:', classifyResponse.data.document_type);
      return classifyResponse.data.document_type;
    } catch (error) {
      console.error('Error during document classification:', error);
      throw new Error('Failed to classify document');
    }
  }

  private async createAndSaveDocument(
    file: Express.Multer.File,
    candidatId: number,
    documentType: string,
    enhancedImages: string[]
  ) {
    const createDocumentDto = new CreateDocumentDto();
    createDocumentDto.nom = file.originalname;
    createDocumentDto.type = documentType;
    createDocumentDto.file = JSON.stringify(enhancedImages);
    createDocumentDto.status = 'In Progress';

    try {
      const newDocument = await this.documentService.addDocumentForUser(candidatId, createDocumentDto);
      return newDocument;
    } catch (error) {
      console.error('Error saving document:', error);
      throw new Error('Failed to save document');
    }
  }